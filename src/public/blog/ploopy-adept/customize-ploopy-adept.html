<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Customizing the Ploopy Adept Trackball - Ryan Heisler's Blog</title>
    <meta name="author" content="Ryan Heisler">
    <meta name="description"
          content="How I customized my Ploopy Adept trackball for ergonomics and to make it work well on MacOS, including customizations to the underlying QMK-based firmware.">
    <!--TODO update dates-->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "headline": "Customizing the Ploopy Adept Trackball",
        "image": [
          "images/rep-1x1.jpg",
          "images/rep-4x3.jpg",
          "images/rep-16x9.jpg"
        ],
        "datePublished": "2025-11-30T20:50:00+00:00",
        "dateModified": "2025-11-30T20:50:00+00:00",
        "author": [
          {
            "@type": "Person",
            "name": "Ryan Heisler",
            "url": "https://ryanheisler.com"
          }
        ]
      }
    </script>

    <link rel="icon" type="image/png" href="../../favicon/favicon-96x96.png"
          sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../../favicon/favicon.svg" />
    <link rel="shortcut icon" href="../../favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180"
          href="../../favicon/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Ryan Heisler" />
    <link rel="manifest" href="../../manifest.webmanifest">
    <meta name="theme-color" content="#181818" media="(prefers-color-scheme: dark)">
    <meta name="theme-color" content="#FDFAF1" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="../../common.css">
    <link rel="stylesheet" href="../../blog.css">
    <link rel="stylesheet" href="../../fonts/inter.css">
    <link rel="stylesheet" href="../../fonts/jetbrains-mono.css">
  </head>
  <body>
    <div class="content-container">
      <main>
        <article>
          <h1>My Ploopy Adept Customizations: Ergonomics and How to Solve Drag Scroll Issues with Custom Firmware and
            Vial</h1>
          <p class="byline">
            By Ryan Heisler, published
            <!--TODO update dates-->
            <time datetime="2025-01-12">January 12, 2025</time>
          </p>
          <div class="image-container">
            <img srcset="images/banner-640.jpg 640w,
                         images/banner-768.jpg 768w,
                         images/banner-1024.jpg 1024w,
                         images/banner-1200.jpg 1200w,
                         images/banner-1440.jpg 1440w,
                         images/banner-1600.jpg 1600w,
                         images/banner-1920.jpg 1920w,
                         images/banner-2560.jpg 2560w,
                         images/banner-3264.jpg 4080w,"
                 sizes="95vw"
                 src="images/banner-640.jpg"
                 alt="A person in the distance walks across the coast of Maine, USA. The shore is covered in sharp rocks and boulders, seaweed, and further away, pine and other trees">
          </div>
          <p>I've been struggling with the ergonmics of my keyboard and mouse lately. I recently bought a Ploopy Adept
            to see if it helped with my ergonomic issues and because it's highly customizeable. I've made a few
            customizations I'm super happy with, and I want to share them in case it can help others get the most out of
            their QMK devices.
          </p>

          <!--TODO: Make these into links-->
          <h2 id="table-of-contents">Table of Contents</h2>
          <ol>
            <li><a href="#customizing-firmware">A note about customizing the firmware</a></li>
            <li><a href="#resources">Resources I used to figure this out</a></li>
            <li><a href="#rotated-adept">Rotate the Adept 180 degrees for negative tilt and easy access to</a> more
              buttons
            </li>
            <li><a href="#separate-toggles">Have access to both momentary and toggled drag scroll</a></li>
            <li><a href="#drag-scroll-macos">Make dragscroll work reliably on MacOS</a></li>
            <li><a href="#conclusions">Conclusions</a></li>
          </ol>

          <h2 id="customizing-firmware">Customizing your firmware</h2>
          <p>For all of these customizations I used Vial and Vial-compatible firmware. The Ploopy Adept does not ship
            with Vial-compatible firmware. You will have to compile and flash the firmware onto your device on your
            own.</p>
          <ol>
            <li><strong>Warning: You do this at your own risk.</strong> I'm not responsible if you brick your trackball
              (but Ploopy can has a way to flash new firmware if you do brick it)
            </li>
            <li>I cannot help you do anything I've done. I'll give as much info as I can in this post, but it's up to
              you to figure it out.
            </li>
            <li>You don't need Vial to do any of the things I've done, but you do need it for some specific
              enhancements.
            </li>
          </ol>

          <h3 id="via-and-vial">What are VIA and Vial?</h3>

          <p>
            <a href="https://caniusevia.com/">VIA is an application for configuring the layout of keyboards.</a> It
            works with keyboards that use <a href="https://docs.qmk.fm/">a popular open-source firmware called
            <abbr>QMK</abbr> (Quantum, Mechanical Keyboard).</a> All Ploopy devices ship with QMK, so you can use VIA to
            configure the layout of any Ploopy device out of the box.
          </p>

          <p>Similarly, <a href="https://get.vial.today/">Vial is open-source software for configuring your keyboard
            that uses a fork of QMK.</a> It has all the features VIA offers plus a few more. One of the features Vial
            has that VIA doesn't is called "tap dance". It lets you configure a key to do one thing when tapped, another
            when held, etc.
          </p>

          <p>You don't need Vial to do any of the things I've done with my adept - you can edit the code, compile it,
            and flash it using QMK alone, and then configure macros and layers with VIA. I used Vial because I thought I
            needed tap dance. It turned out not to be useful for me with the Adept, but I kept Vial anyway in case I
            need its features in the future.
          </p>

          <h2 id="resources">Resources</h2>
          <p><a href="customize-ploopy-adept.html">Ploopy offers some good advice on compiling and flashing QMK firmware
            to your device.</a> Start there, but be aware that their instructions are not specific to Vial. You will
            need their instructions to know how to put the device into bootloader mode so you can flash new firmware
            onto it.
          </p>
          <p><a href="https://get.vial.today/manual/first-use.html#4-my-keyboard-isnt-discovered-or-it-doesnt-work">I
            used Vial's instructions to set up my development environment (as of this writing, steps 1-4 at the bottom
            of this page).</a> That includes installing QMK, cloning Vial's fork of QMK, and compiling and flashing
            their firmware onto your device.
          </p>
          <p>I'll list the file path for every file I changed. All file paths are in the directory of the Vial fork of
            QMK that you'll clone if you want to follow along.
          </p>

          <h2 id="rotated-adept">Rotated Adept</h2>
          <p>I work at a computer 40+ hours a week, and I've been feeling some pain in my arms recently. I surmised this
            was caused by repetitive stress and resting my arms and wrists on my desk and chair. Your mileage will vary,
            but negative keyboard tilt has helped me - tilting the spacebar end of the keyboard up so my wrists tilt
            down while I'm typing. I figured why not try the same with the Adept. The Adept has a positive tilt, so all
            I needed to do was rotate it 180 degrees.
          </p>
          <p>An added benefit of doing this is that I have easy access to 4 of the Adept's 6 buttons with my thumb and
            pinky. I've found I like to move the ball with my fingertips, so it's nice to only have to reach over it for
            two of the buttons.
          </p>
          <!--TODO make image-->
          <!--          <img>-->

          <h3 id="invert-trackball">Invert the Trackball</h3>
          <p>In order to use the adept like this, we need to invert the trackball's X and optionally Y dimensions. By
            default, the trackball is inverted in the Y direction but not the X direction. This makes the cursor go up
            when you rotate the ball away from yourself, and to the right when you rotate it right.
          </p>
          <p>I like this configuration, so I have to invert both the X and Y axes from the setting the Adept ships with.
          </p>
          <p>In keyboards/ploopyco/madromys/config.h I commented out the Y invert, but uncommented the X invert and the
            Dragscroll invert. This makes the ball behave as expected when the device is rotated 180 degrees. <a
             href="https://github.com/lortimer/qmk-firmware/commit/eb44d8d10176426cce93231c50c853d556fb4faa#diff-19ad4cb92fd4e9b075244e89ea1cf3f71178a69db2bb84d105ac5930a235bf60R24">Click
              here to see that file in context with this change.</a>
          </p>

          <div class="code-container">
            <p class="visually-hidden">the following is a C code sample taken from
              keyboards/ploopyco/madromys/config.h</p>
            <div class="code-label" aria-hidden="true">C - keyboards/ploopyco/madromys/config.h</div>

            <pre class="code-block">
<code>//#define POINTING_DEVICE_INVERT_Y // Don't invert Y so I can use Adept upside down
#define POINTING_DEVICE_INVERT_X // Invert X so I can use Adept upside down
#define PLOOPY_DRAGSCROLL_INVERT // Invert drag scroll direction so I can use Adept upside down
</code></pre>
          </div>

          <p>Compiling the firmware with these changes in keyboards/ploopyco/madromys/config.h file makes the trackball
            behave as expected when the device is rotated 180 degrees.
          </p>

          <h3 id="vial-keymap-layout">Vial Keymap Layout</h3>
          <p>Now we need to adjust the keymap in Vial to make sure the keys are laid out how we want. The keymap in vial
            shows the keys laid out as they are with the device facing the intended direction, and I thought I would
            make mistakes trying to remap the keys that way. Instead, I wanted to rotate the keys in the keymap that
            appears in Vial.
          </p>
          <p>I did this by editing the layout in keyboards/ploopyco/madromys/keymaps/vial/vial.json. It took a while to
            figure out how to do this, because the layout system it uses is not documented anywhere that I could find,
            and it's unlike any other layout system I've ever used. Once I understood it, I realized this system makes
            it easy to lay out many keys on a row-based keyboard. I've documented what I learned about it below.
          </p>
          <p><a
           href="https://github.com/lortimer/qmk-firmware/commit/eb44d8d10176426cce93231c50c853d556fb4faa#diff-ef1af7aca5dc0ad35b5ec39187cdac9f04f2cdcbc039ba14b09ca5124954d042R12">Click
            here to see the 180-degree-rotated layout in Github.</a> You may have to scroll down to the vial.json file.
          </p>
          <p>Compiling the firmware with this file makes the adept's buttons appear in the 180-degree-rotated
            orientation in Vial.
          </p>
          <!--TODO make image-->
          <!--          <img>-->

          <h4 id="layout-system">How does the layout system work?</h4>
          <p>In keyboards/ploopyco/madromys/keymaps/vial/vial.json layouts.keymap is an array of object/string pairs.
            First comes an object representing coordinates and size of a button, then a string representing which button
            this object refers to. The string is formatted as ","column", and I believe this must correspond to the row
            and column keyboards/ploopyco/madromys/info.json, although I haven't seen how that file affects Vial.
          </p>
          <p>As far as I can tell, each keymap object can contain 4 fields, and all of them are optional.</p>
          <ul>
            <li>a horizontal coordinate, "x"</li>
            <li>a vertical coordinate, "y"</li>
            <li>a height value, "h"</li>
            <li>a width value, "w"</li>
          </ul>

          <h5 id="height-and-width">Height and Width</h5>
          <p>Each key has a height and width of 1 arbitrary unit, so they appear as squares in Vial by default.</p>
          <p>I let the smaller buttons on the adept be height 1, and I gave the larger buttons a height of 1.5. That way
            they appear to be about the right size compared to the small buttons.
          </p>

          <h5 id="x-and-y">X and Y</h5>
          <p>x's and y's default values are relative to the location of the previous button in the array. x's is also
            relative to the previous button's width.
          </p>
          <p>A button's x coordinate is where the left edge will be, and its y coordinate is where the top edge of the
            button will be. A larger x value is farther to the right than a smaller one, and a larger y value is farther
            down than a smaller one.
          </p>
          <p>The first button in my array is the bottom-left button if you're looking at the Adept as it was intended to
            be used, but for me is the top-right. I'll draw the buttons moving clockwise from that button. It has (x,y)
            coordinates of (0,0), which is the default for the first button, but I've set it explicitly.
          </p>
          <p>I want the second button to appear below the first and aligned with it horizontally. Here's where it gets
            tricky.
          </p>
          <p>The default x coordinate for the next button in the array is at the right edge of the previous button by
            default. That makes sense if you're usually laying out rows of many keys that all touch each other as on a
            standard keyboard.
          </p>
          <p>You can derive the next button's default x coordinate by adding the previous button's width to its x. For
            the second button in my array, the default x is 0 (previous x) + 1 (height) = 1. However, I want my second
            button's left edge to align with the first button's left edge, so I have to subtract the first button's
            width from its x. 0 (previous button's x) - 1 (previous button's width) gives us an x of -1. Remember, this
            is relative to the default for this button, not absolute, so it will align the second button horizontally
            with the first.
          </p>
          <p>The default y coordinate for the next button is the same as the y coordinate for the previous button.
            That's because keyboards are typically laid out in rows. I want my second button to be below the previous
            button, with a little space in between. To make that happen I have to add the height and y coordinate of the
            previous button and then add an offset. 0 (previous y) + 1.5 (height) + 0.1 (offset) gives the second button
            a y coordinate of 1.6.
          </p>
          <p>Continuing from there, the next button, one of the small ones, has an x of -2.1 so it is a full key plus an
            offset to the left of the previous button. It has a y of 0.52 so its bottom edge aligns with the previous
            button. We continue in this way until all the buttons are laid out.
          </p>

          <h2 id="separate-toggles">Separate Momentary and Toggle Drag Scroll</h2>
          <p>The firmware Ploopy provides for the Adept includes a special key definition and custom C code for drag
            scroll. Activating drag scroll makes the trackball scroll instead of moving the mouse cursor.
          </p>
          <p>In keyboards/ploopyco/madromys/config.h, you can define <span class="code-snippet"><code>PLOOPY_DRAGSCROLL_MOMENTARY</code></span>
            to activate drag scroll only while the key is held down, called "momentary" drag scroll. Or you can comment
            that line out to make the drag scroll button toggle the feature on and off.
          </p>
          <p>I wanted both. I usually prefer to use momentary drag scroll because it gives me the flexibility to quickly
            scroll a little bit while also clicking on things. If I'm scrolling a very long document and not using the
            mouse otherwise, I may want to toggle it on to give my hand a break from holding the button.
          </p>
          <p>We need changes to a few files to do this. All of the changes required can be found in this commit on
            Github.
          </p>
          <p>First, we need a new keycode to represent momentary drag scroll. We'll treat the existing keycode as the
            toggle drag scroll. Custom keycodes are enumerated in keyboards/ploopyco/ploopyco.h in an enum called ploopy
            keycodes. We'll add <span class="code-snippet"><code>DRAG_SCROLL_MOMENTARY</code></span> at the end as in
            the code snippet below.
          </p>

          <div class="code-container">
            <p class="visually-hidden">the following is a C code sample taken from keyboards/ploopyco/ploopyco.h</p>
            <div class="code-label" aria-hidden="true">C - keyboards/ploopyco/ploopyco.h</div>

            <pre class="code-block">
<code>enum ploopy_keycodes {
    DPI_CONFIG = QK_KB_0,
    DRAG_SCROLL,
    DRAG_SCROLL_MOMENTARY,
};
</code></pre>
          </div>

          <p>Now we can use our new keycode in the code that toggles drag scroll in keyboards/ploopyco/ploopyco.c.
            Before we change anything, observe in the code snippet below that the process_record_kb function checks
            whether <span class="code-snippet"><code>PLOOPY_DRAGSCROLL_MOMENTARY</code></span> is defined in
            keyboards/ploopyco/madromys/config.h. If it is, it sets a variable called is_drag_scroll to activate
            dragscroll if the key is currently held down. If not, it toggles that variable.
          </p>

          <div class="code-container">
            <p class="visually-hidden">the following is a C code sample taken from keyboards/ploopyco/ploopyco.c.</p>
            <div class="code-label" aria-hidden="true">C - keyboards/ploopyco/ploopyco.c</div>

            <pre class="code-block">
<code>bool process_record_kb(uint16_t keycode, keyrecord_t* record) {
  // ...other code here
  if (keycode == DRAG_SCROLL) {
  #ifdef PLOOPY_DRAGSCROLL_MOMENTARY
    is_drag_scroll = record->event.pressed;
  #else
    if (record->event.pressed) {
      toggle_drag_scroll();
    }
  #endif
  }
  // ...other code here
}

</code></pre>
          </div>

          <p>We can change this section of the function to look for our new keycode instead of looking for <span
           class="code-snippet"><code>PLOOPY_DRAGSCROLL_MOMENTARY</code></span>, as in the code snippet below
          </p>

          <div class="code-container">
            <p class="visually-hidden">the following is a C code sample taken from keyboards/ploopyco/ploopyco.c.</p>
            <div class="code-label" aria-hidden="true">C - keyboards/ploopyco/ploopyco.c</div>

            <pre class="code-block">
<code>if (keycode == DRAG_SCROLL) {
  if (record->event.pressed) {
    toggle_drag_scroll();
  }
}

if (keycode == DRAG_SCROLL_MOMENTARY) {
  is_drag_scroll = record->event.pressed;
}
</code></pre>
          </div>

          <p>Finally, we need to tell Vial about our new keycode so it will be available to assign to a button when
            we're editing the keymap. We add it to the "customKeycodes" array in
            keyboards/ploopyco/madromys/keymaps/vial/vial.json, and give it a name, title, and short name as in the
            following code snippet.
          </p>

          <div class="code-container">
            <p class="visually-hidden">the following is a JSON code sample taken from
              keyboards/ploopyco/madromys/keymaps/vial/vial.json</p>
            <div class="code-label" aria-hidden="true">JSON - keyboards/ploopyco/madromys/keymaps/vial/vial.json</div>

            <pre class="code-block">
<code> "customKeycodes": [
  {
    "name": "DPI Config",
    "title": "DPI Config",
    "shortName": "DPI"
  },
  {
    "name": "Toggle Drag Scroll",
    "title": "Toggle Drag Scroll",
    "shortName": "Drag\nScrl"
  },
  {
    "name": "Momentary Drag Scroll",
    "title": "Momentary Drag Scroll",
    "shortName": "MDrag\nScrl"
  },
],
</code></pre>
          </div>


          <h2 id="drag-scroll-macos">Making drag scroll work consistently on MacOS</h2>
          <p>I use MacOS for work. <a href="mailto:info@ryanheisler.com">You can send your condolences to
            info@ryanheisler.com.</a> When I switched to using the Adept on Mac I noticed that drag scroll would work
            sometimes and not others. I would have to press and hold momentary drag scroll two to five times before it
            would scroll.
          </p>

          <h3 id="investigation">Investigation</h3>
          <p>When it didn't work, the mouse cursor would not move. The drag scroll code prevents the cursor from moving,
            so I took this as evidence that the Adept knew I was trying to scroll but the operating system wasn't
            recognizing the scroll events coming from the Adept.
          </p>
          <p>Searching the web, <a
           href="https://www.reddit.com/r/ploopy/comments/1cp57m6/scrolling_issue_scroll_wheel_and_drag_scroll_with/">I
            found someone complaining of a similar issue in the Ploopy subreddit two years ago.</a> Despite posting
            there and in the QMK subreddit, they never got a resolution.
          </p>

          <h3 id="failure-mouse-wheel-events">Failed Attempt to Use Mouse Wheel Events</h3>
          <p>keyboards/ploopyco/ploopyco.c has a function called "pointing_device_task_kb", which processes mouse
            updates, and it's where the drag scroll functionality is actually implemented. It makes drag scroll work by
            following the steps below. <a
             href="https://github.com/lortimer/qmk-firmware/blob/413f8951fa62bf94c98e9707686ef2130bab34f0/keyboards/ploopyco/ploopyco.c#L141">You
              can see the implementation of drag scroll here on Github.</a>
          </p>
          <ol>
            <li>Get x and y from the current mouse report. These represent vertical and horizontal changes in the mouse
              cursor's position since the last time the position was updated.
            </li>
            <li>Divide these values by a configured divisor (to allow the user to control how fast or slow the drag
              scroll goes)
            </li>
            <li>Assign these values to the mouse report's v (vertical) and h (horizontal) fields, which the operating
              system will interpret as a scroll event.
            </li>
            <li>Set the mouse report's x and y to 0 to prevent the mouse cursor from moving.</li>
          </ol>
          <p>I have a third-party mouse with a scroll wheel and it works just fine on a Mac. I figured this method of
            scrolling using the mouse report's v and h might be poorly supported on MacOS, and that leads to it working
            intermittently. Looking at the standard keycodes available in Vial, I noticed that there are some
            representing the mouse wheel going up, down, right, or left. These are no doubt included so you can make a
            key on your keyboard scroll when pressed. I thought they might help me scroll in a different way that's
            better supported by MacOS.
          </p>
          <p>To make this happen, I implemented two new custom keycodes - DRAG_SCROLL_MACOS and
            DRAG_SCROLL_MOMENTARY_MACOS. Instead of setting the v and h on the mouse report, they called a function to
            tap the correct mouse wheel event keycode based on how the trackball moved. <a
             href="https://github.com/lortimer/qmk-firmware/commit/36f290f1b2dc5a9e00a83faba2dead534d5a6821#diff-5f763322c53918e554122f33ae3ca19598084b9e5356cfdef6efa9625bab6c7cR170">You
              can see how I implemented drag scroll with mouse wheel events here, in keyboards/ploopyco/ploopyco.c
              starting on line 172.</a>
          </p>
          <p>This didn't work. It had the same problem where scrolling would only work some of the time on MacOS, but it
            was worse than before because when scrolling did work it was choppier and harder to control.
          </p>

          <h3 id="scrolling-multiple-directions">Scrolling in Multiple Directions</h3>
          <p>When I tried using my new scrolling behavior on a Mac, I noticed something new. When I was scrolling
            vertically it would not scroll horizontally no matter how much I rotated the trackball sideways. Similarly,
            if I was scrolling horizontally it wouldn't scroll vertically. The reddit post I linked above mentioned that
            scrolling would work again if they waited a few seconds with the button held down, so I tried this. Lo and
            behold I could scroll in my desired direction again if I waited a few seconds, even if I was switching from
            horizontal to vertical.
          </p>
          <p>I investigated further - could I scroll in multiple dimensions at once using the trackpad built into the
            Macbook? No! And that was true across apps. Apparently, MacOS prevents you from scrolling vertically and
            horizontally at the same time.
          </p>

          <h4 id="scrolling-one-direction">Only Scrolling in One Direction</h4>
          <p>The only feasible solution I could think of was to limit scrolling to the vertical dimension when using
            drag scroll on MacOS. It would be a little annoying that I could only scroll vertically, but much less
            annoying than having to click and hold </p>
          <p><a href="https://docs.qmk.fm/features/os_detection">Conveniently, QMK offers an option to detect the
            current operating system the device is connected to.</a> It will tell your code whether the device is using
            MacOS, iOS, Linux, or Windows, and it will give a value called "unsure" if it can't tell. I tried to use
            this feature to change the behavior of the drag scroll functionality, but unfortunately it didn't work for
            me. Maybe I implemented it wrong, but I didn't want to waste a lot of time debugging because QMK's
            documentation says it might not always work correctly.
          </p>
          <p>Instead, I implemented two new keycodes, one for drag scroll and one for momentary drag scroll specifically
            on MacOS. When those keys are used, the drag scroll functionality works as expected, except that it ignores
            all horizontal movement. That way, the mouse report's h value is always 0, so the operating system can't
            misinterpret a vertical scroll with a little horizontal movement as a horizontal scroll. ,<a
             href="https://github.com/lortimer/qmk-firmware/commit/de39b7ef77e49706fec5a8fcbef4422c6b4f2e34#diff-5f763322c53918e554122f33ae3ca19598084b9e5356cfdef6efa9625bab6c7c">You
              can see the implementation of vertical-only MacOS drag scroll in this commit on Github.</a>
          </p>
          <p>To be able to use these new keys with relative ease, I created a second base layer in my Adept button
            layout. Layer 0, the default layer, still has the normal drag scroll button. Layer 1 is a copy of layer 0
            but with the MacOS drag scroll functionality instead. To toggle between the two, I set up a "combo" - when I
            tap two specific buttons at the same time, the Adept switches to using the other layer.
          </p>

          <h2 id="conclusions">Conclusions</h2>
          <p>First, QMK is awesome. All of the customizations I've made to my Adept were possible and even relatively
            easy thanks to the work of the QMK and Vial communities. Not only that, the customizations are stored on the
            Adept itself, meaning I don't need to use any special configuration software on each of my operating systems
            to make the device function as expected.
          </p>
          <p>That's a huge improvement over a device like my Logitech M500 mouse. Just to make the back and forward
            buttons on that mouse work as expected, you have to install a special Logitech app to assign that behavior
            to each button. If Logitech decided to stop supporting that app or my mouse, those buttons just wouldn't
            work on Linux or MacOS. If something like that happens with the Adept, QMK, Vial, or the operating systems I
            use, I can still write my own firmware for the Adept to keep it working long into the future.
          </p>
          <p>Second, Ploopy and the Adept have impressed me with their open-source model and the quality of the device
            they sent me. I've never been a fan of 3D printing because it creates a lot of plastic waste from test
            prints and mistakes. Of course, all plastic devices lead to plastic waste, that was an excuse not to engage
            with 3D printing. Using the Adept, I've come to realize that a 3D printed device like the Adept will last
            longer and create less waste overall because it's customizable enough to survive the events that will make
            my other devices obsolete in the next couple decades.
          </p>
          <p>I also figured 3D-printed plastics couldn't possibly be durable. So far, the Adept seems just as durable as
            the mouse it replaced. The buttons seem like the most likely part to wear out over time, but even if they
            do, I can replace only the top part of the case and reuse the bottom and the circuit board, leading to less
            waste overall. If any of the electronic components fail, I can just replace them with another off the shelf
            rather than buying a whole new device. That's also true of many closed-source devices, but it's much harder
            to figure out what part you need, source it, and replace it.
          </p>
          <p>Finally, the flexibility of a QMK device makes it much easier to adjust it for ergonomics. The fact that I
            can remap the buttons and redraw the button layout means I can orient it however I want. I ended up moving
            away from negative tilt on the Adept, but I still wanted to keep it rotated by 180 degrees. I gave it a
            slight positive tile and tented it to the right using a couple of rubber wedges, and now I'm very
            comfortable using it for hours at a time. I could create a layer to flip the buttons to use it with my left
            hand when I want to switch, or I could print a whole new case that fits the whole thing into a glove.
            Anything is possible with the same device because it's so flexible and open.
          </p>

        </article>
        <a href="/" class="back-to-homepage-end-link"><span aria-hidden="true">&larr; </span>Back to the home page</a>
      </main>
    </div>
  </body>
</html>
